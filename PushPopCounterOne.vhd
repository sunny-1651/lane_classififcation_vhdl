-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc/LaneDetectionHDL/PushPopCounterOne.vhd
-- Created: 2021-11-11 22:20:35
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: PushPopCounterOne
-- Source Path: LaneDetectionHDL/HDLLaneDetector/LaneDetection/VerticallyOrientatedFilter/LineBuffer/DATA_MEMORY/PushPopCounterOne
-- Hierarchy Level: 5
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY PushPopCounterOne IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        hStartIn                          :   IN    std_logic;
        popIn                             :   IN    std_logic;
        popEnable                         :   IN    std_logic;
        hEndIn                            :   IN    std_logic;
        wrAddr                            :   OUT   std_logic_vector(10 DOWNTO 0);  -- ufix11
        pushOut                           :   OUT   std_logic;
        rdAddr                            :   OUT   std_logic_vector(10 DOWNTO 0);  -- ufix11
        popOut                            :   OUT   std_logic;
        EndofLine                         :   OUT   std_logic
        );
END PushPopCounterOne;


ARCHITECTURE rtl OF PushPopCounterOne IS

  -- Signals
  SIGNAL writeCount                       : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL intdelay_reg                     : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL writeStoreEn                     : std_logic;
  SIGNAL writeCountNext                   : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL writeCountCurrent                : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL readReset                        : std_logic;
  SIGNAL InBetweenEn                      : std_logic;
  SIGNAL ConstantZero                     : std_logic;
  SIGNAL InBetweenRegIn                   : std_logic;
  SIGNAL InBetween                        : std_logic;
  SIGNAL readCountCompare                 : std_logic;
  SIGNAL popTerm2                         : std_logic;
  SIGNAL relop_relop1                     : std_logic;
  SIGNAL popTerm1                         : std_logic;
  SIGNAL popCounter                       : std_logic;
  SIGNAL readReset_1                      : std_logic;
  SIGNAL readPop                          : std_logic;
  SIGNAL readCount                        : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL popcountless                     : std_logic;
  SIGNAL relop_relop1_1                   : std_logic;
  SIGNAL startOrEnd                       : std_logic;
  SIGNAL constantTwo                      : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL readCountAhead                   : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL relop_relop1_2                   : std_logic;

BEGIN
  -- Free running, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  Write_Count_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        writeCount <= to_unsigned(16#000#, 11);
      ELSIF enb = '1' THEN
        IF hStartIn = '1' THEN 
          writeCount <= to_unsigned(16#000#, 11);
        ELSIF popIn = '1' THEN 
          writeCount <= writeCount + to_unsigned(16#001#, 11);
        END IF;
      END IF;
    END IF;
  END PROCESS Write_Count_process;


  wrAddr <= std_logic_vector(writeCount);

  pushOut <= popIn;

  intdelay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg(0) <= hEndIn;
        intdelay_reg(1) <= intdelay_reg(0);
      END IF;
    END IF;
  END PROCESS intdelay_process;

  writeStoreEn <= intdelay_reg(1);

  reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        writeCountNext <= to_unsigned(16#000#, 11);
      ELSIF enb = '1' AND writeStoreEn = '1' THEN
        writeCountNext <= writeCount;
      END IF;
    END IF;
  END PROCESS reg_process;


  reg_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        writeCountCurrent <= to_unsigned(16#000#, 11);
      ELSIF enb = '1' AND hStartIn = '1' THEN
        writeCountCurrent <= writeCountNext;
      END IF;
    END IF;
  END PROCESS reg_1_process;


  readReset <=  NOT hStartIn;

  InBetweenEn <= hStartIn OR hEndIn;

  ConstantZero <= '0';

  
  InBetweenRegIn <= hEndIn WHEN hStartIn = '0' ELSE
      ConstantZero;

  reg_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        InBetween <= '0';
      ELSIF enb = '1' AND InBetweenEn = '1' THEN
        InBetween <= InBetweenRegIn;
      END IF;
    END IF;
  END PROCESS reg_2_process;


  popTerm2 <= readCountCompare AND InBetween;

  readCountCompare <= popEnable AND relop_relop1;

  popTerm1 <= popIn AND readCountCompare;

  popCounter <= popTerm1 OR popTerm2;

  readResetREG_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        readPop <= '0';
      ELSIF enb = '1' THEN
        IF readReset_1 = '1' THEN
          readPop <= '0';
        ELSIF hStartIn = '1' THEN
          readPop <= hStartIn;
        END IF;
      END IF;
    END IF;
  END PROCESS readResetREG_process;


  
  relop_relop1 <= '1' WHEN readCount < writeCountCurrent ELSE
      '0';

  popcountless <= popCounter AND (relop_relop1 AND readPop);

  
  relop_relop1_1 <= '1' WHEN readCount = writeCountCurrent ELSE
      '0';

  readReset_1 <= popIn AND (relop_relop1_1 AND readReset);

  startOrEnd <= hStartIn OR readReset_1;

  -- Free running, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  Read_Count_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        readCount <= to_unsigned(16#000#, 11);
      ELSIF enb = '1' THEN
        IF startOrEnd = '1' THEN 
          readCount <= to_unsigned(16#000#, 11);
        ELSIF popcountless = '1' THEN 
          readCount <= readCount + to_unsigned(16#001#, 11);
        END IF;
      END IF;
    END IF;
  END PROCESS Read_Count_process;


  rdAddr <= std_logic_vector(readCount);

  popOut <= popCounter;

  constantTwo <= to_unsigned(16#005#, 11);

  readCountAhead <= readCount + constantTwo;

  
  relop_relop1_2 <= '1' WHEN readCountAhead = writeCountCurrent ELSE
      '0';

  EndofLine <= relop_relop1_2;

END rtl;

